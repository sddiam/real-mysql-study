# 트랜잭션
> 트랜잭션이란 작업의 완전성을 보장하는 작업으로, 여러개의 절차를 포함한 작업이 중단되었을 때 작업의 일부만 적용되지 않게 하기 위한 기능이다.

트랜잭션을 지원하는 스토리지 엔진은 innodb, 지원하지 않는 스토리지 엔진은 MyISAM과 MEMORY이다.

트랜잭션의 유무를 비교해보자
![image](https://github.com/user-attachments/assets/cf48225b-6a79-48fa-b863-249dee8ab3cf)
여기 보면 같은 테이블을 만들고 똑같은 값을 넣었다

그리고 기존에 있던 값을 다시 넣었기에 오류가 떴다

![image](https://github.com/user-attachments/assets/d3dd53f6-b2fe-4398-97fc-6fe74bee706b)

결과를 보면 MyISAM을 사용한 테이블에는 1,2,3 이 들어있고
innodb를 사용한 테이블에는 3만 존재한다

**즉, 트랜잭션 기능이 있으면 ERROR가 발생해 중단되었을 때 이전 상태로 되돌아 간다는 것을 알 수 있다.**

## 주의사항 📝
> 트랜잭션은 최소의 코드에만 적용하는 것이 좋다

모든 코드 절차에 트랜잭션이 좋은 것은 아니다❌

특히 메일 전송, 파일 전송 또는 네트워크를 통한 원격 서버와의 통신 등의 작업들에서 트랜잭션이 기능한다면
웹 서버 뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생한다

또한 DB작업이 아닌 작업은 트랜잭션을 포함시키지 않는 것이 좋다

**트랜잭션이 필요한 부분만 확인하여 트랜잭션의 범위를 최소화하는 것이 필요하다.**

# 잠금
## MySQL 엔진 잠금

MySQL엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다. 하지만 그 반대의 경우는 아니다❌ (스토리지 엔진 → MySQL 엔진)

MySQL엔진 잠금의 종류는 *잠금의 범위*에 따라 나뉘어진다.


1️⃣ 글로벌 락

> MySQL 서버 전체에 영향을 미치는 가장 범위가 큰 잠금

*잠금실행*
```sql
FLUSH TABLES WITH READ LOCK
```

글로벌 락을 획득한 세션 외의 곳에서 DDL과 DML 문장을 실행하면 글로벌 락 해제 전까지 대기 상태가 된다.
글로벌 락은 보통 MyISAM 과 MEMORY에서 사용되는데, InnoDB가 일반화 되면서 더 가벼운 글로벌 락의 필요성이 생겼다.
Xtrabackup Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입되었다

백업 락을 획득하면 모든 세션에서 다음과 같은 쿼리를 수행할 수 없게 된다
- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

하지만 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.




2️⃣ 테이블 락

> 개별 테이블 단위로 설정되는 잠금

명시적 또는 묵시적으로 테이블 락을 획득할 수 있다

**명시적으로 테이블 락을 획득하는 경우**

*테이블 락 실행*
```sql
LOCK TABLES 테이블이름 [ READ | WRITE ]
```

*잠금 반납*
```sql
UNLOCK TABLES
```

**묵시적으로 테이블 락을 획득하는 경우**

MyISAM나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행할때 발생한다

쿼리가 실행되는 동안 자동으로 획득, 쿼리가 완료된 후 자동 해제한다.
(InnoDB에서는 단순 데이터 변경 쿼리로 인한 테이블 락은 실행되지 않는다)





3️⃣ 네임드 락

> 임의의 문자열에 대한 잠금

데이터베이스 객체가 아닌 단순히 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납한다.

다음과 같은 명령어로 잠금이 실행된다

*문자열에 대해 잠금을 획득하고 이미 잠금이 사용 중이면 n초 동안 대기한다*
```sql
SELECT GET_LOCK('문자열', n)
```

*문자열에 대한 잠금 확인*
```sql
SELECT IS_FREE_LOCK('문자열')
```

*문자열에 대한 잠금 반납*
```sql
SELECT RELEASE_LOCK('문자열')
```





4️⃣ [메타데이터 락](https://dev.mysql.com/doc/refman/8.4/en/metadata-locking.html#metadata-lock-acquisition)

> 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금

명시적인 설정과 해제가 불가능하고 이름과 구조 변경 시 자동으로 획득할 수 있다

*이름을 변경하는 명령어*

```sql
RENAME TABLE tbla TO tbld, tblc TO tbla
```
두개의 RENAME작업을 동시에 진행하는 명령어

이와 같은 명령어는 "Table not found tbla"같은 상황을 발생시키지 않고 적용하는 것이 가능하다

```sql
RENAME TABLE tbla TO tbld;
RENAME TABLE tblc TO tbla;
```

하지만 위와 같이 2개로 나눠서 실행하면 tbla 테이블이 존재하지 않는 순간이 생겨 "Table not found tbla" 오류를 발생시킨다




## InnoDB 스토리지 엔진 잠금

[InnoDB 스토리지 엔진 잠금 종류](https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html)

스토리지 엔진 내부에서 레코드 기반의 잠금 방식이다

MyISAM보다 뛰어난 동시성 처리를 제공하지만 이원화된 잠금 처리 때문에 MySQL 명령을 이용한 접근이 쉽지 않다

예전 서버에서는 lock_monitor과 SHOW ENGINE INNODB STATUS 명령으로 잠금 정보를 진단했지만 최근 버전에서는
- 트랜잭션(INNODB_TRX)
- 잠금(INNODB_LOCKS)
- 잠금 대기 중인 트랜잭션(INNODB_LOCK_WAITS)
  
테이블을 조인해서 조회하면 잠금 상태를 확인할 수 있다.



1️⃣ 레코드 락
> 레코드만을 잠금

DBMS 레코드 락과 동일한 역할을 하지만, InnoDB는 레코드자체가 아닌 인덱스의 레코드를 잠근다.
인덱스가 없는 테이블이어도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정하는데 레코드 자체를 잠그는 것과 인덱스를 잠그는 것에는 중요한 차이가 있다✅

InnoDB에서 PRIMARY KEY또는 UNIQUE 인덱스에 의한 변경 작업에서 갭이 아닌 레코드 자체에 대해서만 락을 건다




2️⃣ 갭 락
> 레코드와 인접한 레코드 사이 간격만을 잠금

갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다. 갭 락은 그 자체보다 넥스트 키 락의 일부로 자주 사용된다.





3️⃣ 넥스트 키 락
> 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금

STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ격리 수준을 사용해야 한다.

innodb_locks_unsafe_for_binlog 시스템 변수가 0으로 설정되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다. 갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.

즉, 레플리카 서버에서 쿼리를 실행할 때 데이터 삽입, 변경의 영향을 받지 않고 소스 서버와 동일한 결과를 유지할 수 있다.

그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 그래서 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.




4️⃣ 자동 증가 락

MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다. 이 칼럼이 사용된 테이블에 여러 레코드가 동시에 INSERT되는 경우, 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.

AUTO_INCREMENT 락은 INSERT, REPLACE같은 새로운 레코드를 저장하는 쿼리에서만 필요하다. 다른 잠금과는 달리 트랜잭션과 관계없이 문장에서 AUTO_INCREMENT값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다. 해당 잠금은 테이블에 단 하나만 존재하기 때문에 두 개의 쿼리가 동시에 실행되는 경우 하나의 쿼리가 락을 걸면 나머지 쿼리는 기다려야 한다.

해당 잠금은 명시적으로 획득 및 해제하는 방법이 없고 아주 짧은 시간 지속되는 잠금이기에 대부분의 경우 문제가 되지 않는다.

MySQL 5.1 이상 버전부터 사용되는 innodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.

- innodb_autoinc_lock_mode = 0

  🔹 모든 insert 문장이 자동 증가 락을 사용한다

- innodb_autoinc_lock_mode = 1

  🔹INSERT되는 레코드의 건수를 예측할 수 있을 때는 Auto increment lock을 사용하지 않는다
  
  🔹가볍고 빠른 래치(뮤텍스)를 이용해 처리하고 이는 자동 증가 락과 달리 짧은 잠금 시간과 필요 자동 증가 값이 있으면 바로 해제됨

  🔹서버가 건수를 예측할 수 없다면 Auto increment lock을 사용한다.

  🔹연속 모드(Consecutive mode)라고도 함

- innodb_autoinc_lock_mode = 2

  🔹절대 자동 증가 락을 걸지 않고 래치(뮤텍스)를 사용한다.

  🔹하나의 INSERT 문장으로 INSERT되는 레코드 라고 하더라도 연속된 자동 증가 값을 보장하지 않음

  🔹인터리빙 모드(Interleaved mode)라고도 함

  🔹대량 INSERT 문장이 실행되는 중에다른 커넥션에서도 INSERT를 사용할 수 있어 동시 처리 성능이 높아짐

  🔹STATEMENT 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있기에 주의해야 함💡

### 인덱스와 잠금

InnoDB의 잠금에서 '레코드 락'은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리된다.

즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

```sql
--employees 테이블에는 아래와 같이 first_name 칼럼만 멤버로 담긴 ix_firstname이라는 인덱스가 준비되어 있다
--first_name='Georgi'이고 last_name='Klassen'인 사원을 찾았다 (1명 출력)

SELECT COUNT(*)
FROM employees
WHERE first_name='Georgi';
--출력값: 200

SELECT COUNT(*)
FROM employees
WHERE first_name='Georgi' AND last_name='Klassen';
--출력값: 1

--이 사원의 입사 일자를 오늘로 변경하는 쿼리를 실행
UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

위의 코드 중 UPDATE 문장이 실행되면 1건의 레코드가 업데이트 된다. 그러면 이 업데이트를 위해 락이 걸린 레코드는 몇개일까?

인덱스를 이용할 수 있는 조건은 first_name='Georgi'로 총 200건의 레코드가 모두 잠긴다.

인덱스가 하나도 없다면, 테이블을 풀 스캔하면서 작업을 진행하기에 
만약 테이블에 10만개의 레코드가 있다면 모두 잠기게 된다.

### 레코드 수준의 잠금 확인 및 해제
InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 복잡하다.

레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리는 것이며 해당 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않기 때문이다.

MySQL 8.0버전부터 앞에서 언급했던 information_schema의 정보들이 조금씩 제고되고 있으며, 대신 performance_schema의 data_locks와 data_lock_waits 테이블로 대체되고 있다.


## MySQL의 격리 수준
트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

MySQL 격리 수준의 구분 

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

4개의 격리 수준에서 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능도 떨어진다.

격리 수준과 함께 언급되는 세 가지 부정합의 문제점. 격리 수준의 레벨에 따라 발생할 수도 있도 발생하지 않을 수도 있다.

|                 |DIRTY READ         |NON-REPEATABLE READ     |PHANTOM READ   |
|-----------------|-------------------|------------------------|---------------|
|READ UNCOMMITTED |발생               |발생                     |발생           |
|READ COMMITTED   |없음               |발생                     |발생           | 
|REPEATABLE READ  |없음               |없음                     |발생           | 
|SERIALIZABLE     |없음               |없음                     |없음           |


1️⃣READ UNCOMMITTED

각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.

즉, 변경된 내용을 커밋하기도 전에 다른 사용자가 정보를 조회할 수 있다.

트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 *Dirty read*라고 한다.
그리고 더티 리드가 허용되는 격리 수준이 READ UNCOMMITTED이다.

⚠️더티 리드는 작업자에게 큰 혼란을 줄 수 있는 문제점이기에 최소한 READ COMMITTED 이상의 격리 수준을 사용할 것을 권장한다 

2️⃣READ COMMITTED

> 오라클 DBMS에서 기본으로 사용되는 격리 수준이다

어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기에 'Dirty read'현상은 발생하지 않는다.

데이터 수정 중 커밋을 수행하기 전에 다른 사용자가 조회를 시도한다면 언두 영역에서 데이터를 조회한다.
커밋을 수행하면 다른 트랜잭션에서도 백업된 언두 레코드가 아닌 새롭게 변경된 데이터를 참조할 수 있게 된다.

이 격리 수준에도 *NON-REPEATABLE READ*라는 부정합의 문제가 있다.

데이터 변경 후 커밋을 실행하면 커밋 실행 전과 후 SELECT 쿼리의 결과가 달라진다.
이는 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 'REPEATABLE READ' 정합성에 어긋난다. 

일반적인 웹 프로그램에서는 문제되지 않을 수 있지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다⚠️


3️⃣REPEATABLE READ
>MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준

트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경하기에 'NON-REPEATABLE READ'부정합이 발생하지 않는다.
MVCC 방식을 이용해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.

모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.
그리고 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

사용자가 BEGIN명령으로 트랜잭션을 시작하면서 번호를 부여받는다. 그리고 그때부터 사용자가 실행하는 모든
SELECT 쿼리는 트랜잭션 번호가 자신의 트랜잭션 번호보다 작은 번호에서 변경한 것만 보이게 된다.

이 격리 수준에서는 *PHANTOM READ*라는 부정합의 문제가 존재하는데, 이는 원래 안 보여야 하는 높은 트랜잭션 번호가 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 의미한다.

4️⃣SERIALIZABLE

가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다

InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다.
하지만 읽기 작업도 공유 잠금을 획득해야 하며, 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.

SERIALIZABLE 격리 수준에서는 'PHANTOM READ' 문제가 발생하지 않는데, InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 때문에 이 전 격리 수준에서도 이미 PHANTOM READ 문제가 발생하지 않는다. 그렇기에 굳이 이 격리 수준을 사용할 필요성은 없다❌ 

